import { app, dialog, BrowserWindow, Menu } from 'electron'
import windowStateKeeper from 'electron-window-state'
import installExtension, { REDUX_DEVTOOLS, REACT_DEVELOPER_TOOLS } from 'electron-devtools-installer';
import * as path from 'path'

import { releaseIpcEvents } from './IPCEvents'
import { IPC } from '../renderer/data/const'
import AppStorage from './data/AppStorage'
import { createMainMenu, createMenuTemplate } from './MainMenu'

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string
declare const WORKER_WINDOW_WEBPACK_ENTRY: string
declare const WORKER_WINDOW_PRELOAD_WEBPACK_ENTRY: string

// Current window list
const currentWindows = new Map<number, BrowserWindow>()
const currentRemoteWindows = new Map<number, BrowserWindow>()
// Current storage list
const currentAppStorages = new Map<number, AppStorage>()

let workerWindow: BrowserWindow | undefined

export function startScene (sceneName: string) {
  const w = currentWindows.get(1)
  if (w) {
    console.log("Attempting to start scene '" + sceneName + "'")
    w.webContents.send(IPC.startScene, sceneName)
  }
}

export function createNewWindow () {
  // Load the previous state with fallback to defaults
  const mainWindowState = windowStateKeeper({
    defaultHeight: 800,
    defaultWidth: 600
  })

  // Create the window using the state information
  const newWindow = new BrowserWindow({
    x: mainWindowState.x,
    y: mainWindowState.y,
    width: mainWindowState.width,
    height: mainWindowState.height,
    icon: path.join(__dirname, 'src/renderer/icons/flipflip_logo.png'),
    title: 'FlipFlip',
    webPreferences: {
      nodeIntegration: true,
      nodeIntegrationInWorker: true,
      webSecurity: false, // TODO remove before packaging
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY
    }
  })

  // Store this window in the map
  const windowId = newWindow.id
  currentWindows.set(windowId, newWindow)
  currentRemoteWindows.set(newWindow.webContents.id, newWindow)

  // Create new AppStorage for this window
  const webContentsId = newWindow.webContents.id
  currentAppStorages.set(webContentsId, new AppStorage(windowId))

  // Only manage the size of the mainWindow
  if (windowId === 1) {
    mainWindowState.manage(newWindow)
  }

  newWindow.on('closed', () => {
    // If we close the main window, close everything
    if (windowId === 1) {
      releaseIpcEvents()
      app.quit()
    } else {
      // Else just remove that window
      currentWindows.delete(windowId)
      currentRemoteWindows.delete(webContentsId)
      currentAppStorages.delete(webContentsId)
    }
  })

  // Add * to extra windows
  newWindow.webContents.on('did-finish-load', () => {
    if (windowId !== 1) {
      newWindow.setTitle(newWindow.getTitle() + '*')
    }
  })

  newWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY)

  // Open the DevTools.
  const isDevToolsDisabled = Boolean(
    process.argv.find((el, i, arr) => {
      return el === '--no-dev-tools'
    })
  )
  if (process.defaultApp && windowId === 1 && !isDevToolsDisabled) {
    // Install developer extensions for debugging
    [REACT_DEVELOPER_TOOLS/*, REDUX_DEVTOOLS*/].forEach((ext) =>  {
      installExtension(ext, {loadExtensionOptions: {allowFileAccess: true}})
        .then((name) => console.log(`Added Extension:  ${name}`))
        .catch((err) => console.log('An error occurred: ', err));
    })

    // Comment the following line out to enable attachment of a remote debugger
    // or to load developer tool extensions
    // newWindow.webContents.openDevTools()
  }

  buildMenu(newWindow)
}

export function createWorkerWindow () {
  // Load the previous state with fallback to defaults
  const workerWindowState = windowStateKeeper({
    defaultHeight: 800,
    defaultWidth: 600
  })

  // Create the window using the state information
  workerWindow = new BrowserWindow({
    x: workerWindowState.x,
    y: workerWindowState.y,
    width: workerWindowState.width,
    height: workerWindowState.height,
    icon: path.join(__dirname, 'src/renderer/icons/flipflip_logo.png'),
    title: 'FlipFlip',
    webPreferences: {
      nodeIntegration: true,
      nodeIntegrationInWorker: true,
      webSecurity: false, // TODO remove before packaging
      preload: WORKER_WINDOW_PRELOAD_WEBPACK_ENTRY
    }
  })

  workerWindow.loadURL(WORKER_WINDOW_WEBPACK_ENTRY)

  // Open the DevTools.
  const isDevToolsDisabled = Boolean(
    process.argv.find((el, i, arr) => {
      return el === '--no-dev-tools'
    })
  )
  if (process.defaultApp && !isDevToolsDisabled) {
    // Comment the following line out to enable attachment of a remote debugger
    workerWindow.webContents.openDevTools()
  }
}

export function getWindowId (id: number): number | undefined {
  return currentRemoteWindows.get(id)?.id
}

export function getAppStorageInitialState (id: number): any | undefined {
  return currentAppStorages.get(id)?.initialState
}

export async function saveAppStorage (
  id: number,
  state: any,
  quickSave: boolean
) {
  currentAppStorages.get(id)?.save(state, quickSave)
}

export function backupAppStorage (id: number, state: any) {
  currentAppStorages.get(id)?.backup(state)
}

export function reloadWindow (id: number): void {
  currentRemoteWindows.get(id)?.reload()
}

export function showWindow (id: number): void {
  currentRemoteWindows.get(id)?.show()
}

export function defaultBuildMenu (id: number) {
  const browserWindow = currentRemoteWindows.get(id) as BrowserWindow
  buildMenu(browserWindow)
}

export function gridToggleFullScreen (id: number) {
  const browserWindow = currentRemoteWindows.get(id) as BrowserWindow
  const menuItems = gridMenuItems(browserWindow)
  toggleFullScreen(browserWindow, menuItems)
}

export function playerToggleFullScreen (id: number, state: PlayerMenuState) {
  const browserWindow = currentRemoteWindows.get(id) as BrowserWindow
  const menuItems = playerMenuItems(browserWindow, state)
  toggleFullScreen(browserWindow, menuItems)
}

function toggleFullScreen (
  browserWindow: BrowserWindow,
  menuItems: Map<string, string[]>
) {
  const fullScreen = !browserWindow.isFullScreen()
  browserWindow.setFullScreen(fullScreen)
  browserWindow.setMenuBarVisibility(fullScreen)
  buildMenu(browserWindow, menuItems)
}

export function gridSetAlwaysOnTop (id: number, alwaysOnTop: boolean) {
  const browserWindow = currentRemoteWindows.get(id) as BrowserWindow
  const menuItems = gridMenuItems(browserWindow)
  setAlwaysOnTop(browserWindow, alwaysOnTop, menuItems)
}

export function playerSetAlwaysOnTop (
  id: number,
  alwaysOnTop: boolean,
  state: PlayerMenuState
) {
  const browserWindow = currentRemoteWindows.get(id) as BrowserWindow
  const menuItems = playerMenuItems(browserWindow, state)
  setAlwaysOnTop(browserWindow, alwaysOnTop, menuItems)
}

function setAlwaysOnTop (
  browserWindow: BrowserWindow,
  alwaysOnTop: boolean,
  menuItems: Map<string, string[]>
) {
  browserWindow.setAlwaysOnTop(alwaysOnTop)
  buildMenu(browserWindow, menuItems)
}

export function gridSetFullScreen (id: number, fullScreen: boolean) {
  const browserWindow = currentRemoteWindows.get(id) as BrowserWindow
  const menuItems = gridMenuItems(browserWindow)
  setFullScreen(browserWindow, fullScreen, menuItems)
}

export function playerSetFullScreen (
  id: number,
  fullScreen: boolean,
  state: PlayerMenuState
) {
  const browserWindow = currentRemoteWindows.get(id) as BrowserWindow
  const menuItems = playerMenuItems(browserWindow, state)
  setFullScreen(browserWindow, fullScreen, menuItems)
}

function setFullScreen (
  browserWindow: BrowserWindow,
  fullScreen: boolean,
  menuItems: Map<string, string[]>
): void {
  browserWindow.setFullScreen(fullScreen)
  buildMenu(browserWindow, menuItems)
}

export function gridMenuBarVisibility (id: number, menuBarVisible: boolean) {
  const browserWindow = currentRemoteWindows.get(id) as BrowserWindow
  const menuItems = gridMenuItems(browserWindow)
  setMenuBarVisibility(browserWindow, menuBarVisible, menuItems)
}

export function playerMenuBarVisibility (
  id: number,
  menuBarVisible: boolean,
  state: PlayerMenuState
) {
  const browserWindow = currentRemoteWindows.get(id) as BrowserWindow
  const menuItems = playerMenuItems(browserWindow, state)
  setMenuBarVisibility(browserWindow, menuBarVisible, menuItems)
}

function setMenuBarVisibility (
  browserWindow: BrowserWindow,
  menuBarVisible: boolean,
  menuItems: Map<string, string[]>
) {
  browserWindow.setMenuBarVisibility(menuBarVisible)
  buildMenu(browserWindow, menuItems)
}

export function playerBuildMenu (id: number, state: PlayerMenuState) {
  const browserWindow = currentRemoteWindows.get(id) as BrowserWindow
  const menuItems = playerMenuItems(browserWindow, state)
  buildMenu(browserWindow, menuItems)
}

export interface PlayerMenuState {
  isPlaying: boolean
  canDelete: boolean
  canChangeSource: boolean
}

function playerMenuItems (
  browserWindow: BrowserWindow,
  state: PlayerMenuState
): Map<string, string[]> {
  // TODO not very efficient to send events back to renderer that then send messages back to the main process
  const menuItems = new Map<string, string[]>([
    [
      IPC.playerPlayPause,
      ['Play/Pause ' + (state.isPlaying ? '(Playing)' : '(Paused)'), 'space']
    ],
    [IPC.playerHistoryBack, ['Back in Time', 'left']],
    [IPC.playerHistoryForward, ['Forward in Time', 'right']],
    [IPC.playerNavigateBack, ['Go Back to Scene Details', 'escape']],
    [
      IPC.playerToggleFullscreen,
      [
        'Toggle Fullscreen ' +
          (browserWindow.isFullScreen() ? '(On)' : '(Off)'),
        'Control+F'
      ]
    ],
    [
      IPC.playerToggleAlwaysOnTop,
      [
        'Toggle Always On Top ' +
          (browserWindow.isAlwaysOnTop() ? '(On)' : '(Off)'),
        'Control+T'
      ]
    ],
    [
      IPC.playerToggleMenuBarDisplay,
      [
        'Toggle Menu Bar ' +
          (browserWindow.isMenuBarVisible() ? '(On)' : '(Off)'),
        'Control+G'
      ]
    ]
  ])

  if (state.canDelete) {
    menuItems.set(IPC.playerDelete, ['Delete Image', 'Delete'])
  }

  if (state.canChangeSource) {
    menuItems.set(IPC.playerPrevSource, ['Previous Source', '['])
    menuItems.set(IPC.playerNextSource, ['Next Source', ']'])
  }

  return menuItems
}

function gridMenuItems (browserWindow: BrowserWindow): Map<string, string[]> {
  // TODO not very efficient to send events back to renderer that then send messages back to the main process
  return new Map<string, string[]>([
    [IPC.gridNavigateBack, ['Go Back to Grid Setup', 'escape']],
    [
      IPC.gridToggleFullscreen,
      [
        'Toggle Fullscreen ' +
          (browserWindow.isFullScreen() ? '(On)' : '(Off)'),
        'Control+F'
      ]
    ],
    [
      IPC.gridToggleAlwaysOnTop,
      [
        'Toggle Always On Top ' +
          (browserWindow.isAlwaysOnTop() ? '(On)' : '(Off)'),
        'Control+T'
      ]
    ],
    [
      IPC.gridToggleMenuBarDisplay,
      [
        'Toggle Menu Bar ' +
          (browserWindow.isMenuBarVisible() ? '(On)' : '(Off)'),
        'Control+G'
      ]
    ]
  ])
}

function buildMenu (
  browserWindow: BrowserWindow,
  menuItems?: Map<string, string[]>
) {
  let playerControls
  if (menuItems) {
    playerControls = {
      label: 'Player controls',
      submenu: Array.from(menuItems.entries()).map(([k, v]) => {
        const [label, accelerator] = v
        return {
          label,
          accelerator,
          click: () => {
            browserWindow.webContents.send(k)
          }
        }
      })
    }
  }

  createMainMenu(Menu, createMenuTemplate(app, playerControls))
}

export function playerBack (id: number) {
  const browserWindow = currentRemoteWindows.get(id) as BrowserWindow
  browserWindow.setFullScreen(false)
  browserWindow.setMenuBarVisibility(true)
}

export async function openAudioFiles (
  id: number
): Promise<string[] | undefined> {
  return await showOpenDialog(id, {
    filters: [
      { name: 'All Files (*.*)', extensions: ['*'] },
      { name: 'Audio files', extensions: ['mp3', 'm4a', 'wav', 'ogg'] }
    ],
    properties: ['openFile', 'multiSelections']
  })
}

export async function openTextFiles (id: number): Promise<string[] | undefined> {
  return await showOpenDialog(id, {
    filters: [
      { name: 'All Files (*.*)', extensions: ['*'] },
      { name: 'Text files', extensions: ['txt'] }
    ],
    properties: ['openFile', 'multiSelections']
  })
}

export async function openJsonFile (id: number): Promise<string | undefined> {
  const paths = await showOpenDialog(id, {
    filters: [
      { name: 'All Files (*.*)', extensions: ['*'] },
      { name: 'JSON Document', extensions: ['json'] }
    ],
    properties: ['openFile']
  })
  return paths ? paths[0] : undefined
}

export async function openSubtitleFile (
  id: number
): Promise<string | undefined> {
  const paths = await showOpenDialog(id, {
    filters: [
      { name: 'All Files (*.*)', extensions: ['*'] },
      { name: 'Web Video Text Tracks (WebVTT)', extensions: ['vtt'] }
    ],
    properties: ['openFile']
  })
  return paths ? paths[0] : undefined
}

export async function openTextFile (id: number): Promise<string | undefined> {
  const paths = await showOpenDialog(id, {
    filters: [
      { name: 'All Files (*.*)', extensions: ['*'] },
      { name: 'Text Document', extensions: ['txt'] }
    ],
    properties: ['openFile']
  })
  return paths ? paths[0] : undefined
}

export async function openDirectory (id: number): Promise<string | undefined> {
  const paths = await showOpenDialog(id, { properties: ['openDirectory'] })
  return paths ? paths[0] : undefined
}

export async function openDirectories (
  id: number
): Promise<string[] | undefined> {
  return await showOpenDialog(id, {
    filters: [{ name: 'All Files (*.*)', extensions: ['*'] }],
    properties: ['openDirectory', 'multiSelections']
  })
}

export async function openVideos (id: number): Promise<string[] | undefined> {
  return await showOpenDialog(id, {
    filters: [
      { name: 'All Files (*.*)', extensions: ['*'] },
      { name: 'Video files', extensions: ['mp4', 'mkv', 'webm', 'ogv', 'mov'] },
      { name: 'Playlist files', extensions: ['asx', 'm3u8', 'pls', 'xspf'] }
    ],
    properties: ['openFile', 'multiSelections']
  })
}

export async function openImageFiles (
  id: number
): Promise<string[] | undefined> {
  return await showOpenDialog(id, {
    filters: [
      { name: 'All Files (*.*)', extensions: ['*'] },
      {
        name: 'Image files',
        extensions: ['gif', 'png', 'jpeg', 'jpg', 'webp', 'tiff', 'svg']
      }
    ],
    properties: ['openFile']
  })
}

async function showOpenDialog (
  id: number,
  options: Electron.OpenDialogOptions
): Promise<string[] | undefined> {
  const currentWindow = currentRemoteWindows.get(id) as BrowserWindow
  const returnValue = await dialog.showOpenDialog(currentWindow, options)
  return !returnValue.canceled ? returnValue.filePaths : undefined
}

export async function saveTextFile (
  id: number,
  defaultPath: string
): Promise<string | undefined> {
  return await showSaveDialog(
    id,
    [{ name: 'Text Document', extensions: ['txt'] }],
    defaultPath
  )
}

export async function saveJsonFile (
  id: number,
  defaultPath: string
): Promise<string | undefined> {
  return await showSaveDialog(
    id,
    [{ name: 'JSON Document', extensions: ['json'] }],
    defaultPath
  )
}

async function showSaveDialog (
  id: number,
  filters: Electron.FileFilter[],
  defaultPath: string
): Promise<string | undefined> {
  const currentWindow = currentRemoteWindows.get(id) as BrowserWindow
  const returnValue = await dialog.showSaveDialog(currentWindow, {
    filters,
    defaultPath
  })
  return returnValue.filePath
}

export function setProgressBar (id: number, progress: number): void {
  currentRemoteWindows.get(id)?.setProgressBar(progress)
}

export async function clearSessionCache (id: number) {
  currentRemoteWindows.get(id)?.webContents.session.clearCache()
}

export function loadInWorker (event: string, args: any[], id: number): void {
  workerWindow?.webContents.send(IPC.workerReceiveMessage, event, args, id)
}

export function workerResponse (id: number, data: any): void {
  currentRemoteWindows.get(id)?.webContents.send(IPC.workerResponse, data)
}
